/***********************************************************************************************************/
#include "stdafx.h"
#include "CAttributeSystem.h"
#include "CCharacter.h"
#include "CharacterList.h"
#include "AttributeAppend.h"
/***********************************************************************************************************/
namespace MG
{
    //-----------------------------------------------------------------------------
#define ATTR_RAND_INDEX 3
#define LVADD_RAND_INDEX 4
    void CAttributeSystem::calBaseAttr(CCharacter* pCharacter)
    {
        //AttributeSet* mCalAttrInfo = getCalAttrInfo();

        //从角色中取得属性，加入属性表中
       /* mCalAttrInfo->setFanalValue( ATTR_ID_LevelBase, (Flt)pCharacter->getLevel() );
        mCalAttrInfo->setFanalValue( ATTR_ID_Hp, (Flt)pCharacter->getHp());
        mCalAttrInfo->setFanalValue( ATTR_ID_Mp, (Flt)pCharacter->getMp());
        mCalAttrInfo->setFanalValue( ATTR_ID_Sp, (Flt)pCharacter->getSp());
        mCalAttrInfo->setFanalValue( ATTR_ID_Awake, (Flt)pCharacter->getLineageNum());*/

        //根据tempID加上附加值。
        //const CharacterTempInfo* mCharacterTempInfo = pCharacter->getCharacterTempInfo();
        //assert(mCharacterTempInfo);
        //for (Int i=0; i<CHAR_ABILITYAPPEND_ID_NUM; i++)
        //{
        //    U32 id = mCharacterTempInfo->getCharacterAbilityAppendId(i);
        //    if ( id == 0 )
        //        break;
        //    const AttributeAppendInfo* pAAinfo = AttributeAppend::getInstance().getAttributeAppendInfo( id );
        //    assert(pAAinfo);

        //    
        //    for ( Int j=0; j<APPENDATTR_NUM; j++ )
        //    {
        //        //先判断类型，在选择计算方法。
        //        Flt tempVal =  mCalAttrInfo->getFanalValue( pAAinfo->AppendAttrList[j].id );
        //        mCalAttrInfo->setFanalValue( pAAinfo->AppendAttrList[j].id, pAAinfo->AppendAttrList[j].value + tempVal );
        //    }

        //}

        ////在根据血脉加上附加值
        //const LineageInfo* pLginfo = LineageTemplate::getInstance().getAttrAppendInfo(lineageAppendAttrid);
        //assert(pLginfo);
        //if ( pLginfo->abilityGroupAppendId != 0 )
        //{
        //    const AttributeAppendInfo* pAAinfo = AttributeAppend::getInstance().getAttributeAppendInfo( pLginfo->abilityGroupAppendId );
        //    assert(pAAinfo);
        //    for ( Int j=0; j<APPENDATTR_NUM; j++ )
        //    {
        //        //先判断类型，在选择计算方法。
        //        Flt tempVal =  mCalAttrInfo->getFanalValue( pAAinfo->AppendAttrList[j].id );
        //        mCalAttrInfo->setFanalValue( pAAinfo->AppendAttrList[j].id, pAAinfo->AppendAttrList[j].value + tempVal );
        //    }
        //}

    }
    //-----------------------------------------------------------------------------
#undef  ATTR_RAND_INDEX
#undef LVADD_RAND_INDEX
    //-----------------------------------------------------------------------------
}